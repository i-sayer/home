<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>SVG MODULE TEST</title>
	<script type="text/javascript" src="nmg2mods.js"></script>
	<!--script type="text/javascript" src="modulejson.js"></script-->
	<!--script type="text/javascript" src="moduleDic.js"></script-->
</head>
<body>
    <style type="text/css">
		body {
			font-family:"segoe ui", sans-serif;
		}
		#options {
			height:48px;
			border:1px solid black;
		}
        svg {
            overflow: visible;
			-webkit-user-select:none;
			-moz-user-select:none;
			user-select:none;
        }
        body {
            background-color: gray;
			margin:0;
        }
		circle.knob {
			/*cursor: url(patch-cursor.png), auto;*/
			cursor:pointer;
		}
		circle.io {
			cursor: url(patch-cursor.png) 0 12, auto;
		}
		text {
			cursor:default;
		}
		g.module {
			width:256px;
		}
		path#svgcable
		{
			stroke-width: 6;
			stroke: rgba(128,128,255,0.7);
			stroke-linecap: round;
			fill: none;
		}
    </style>
	<div id="options">
		<label><input id="knob_shadow" type="checkbox" checked="checked" />Shadow</label>
		<input id="scaler" type="range" min="-7.75" max="-1" step=".125" />
		<input id="shifter" type="range" min="0" max="500" />
	</div>
    <svg xmlns="http://www.w3.org/2000/svg" width="1024" height="600" viewBox="0 0 1024 600" font-family="sans-serif" font-size="9">
        <defs id="alldefs">
		<filter id="f3" x="-20%" y="-20%" width="200%" height="200%">
			<feOffset result="offOut" in="SourceAlpha" dx="1" dy="1" />
			<feGaussianBlur result="blurOut" in="offOut" stdDeviation="2" />
			<feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
		</filter>
		<filter id="f4" x="-10%" y="-10%" width="150%" height="150%">
			<feOffset result="offOut" in="SourceAlpha" dx="0.5" dy="0.5" />
			<feGaussianBlur result="blurOut" in="offOut" stdDeviation="1" />
			<feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
		</filter>

		<linearGradient id="g119" gradientUnits="objectBoundingBox" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop stop-color="rgba(190,190,190,0.35)" offset="0"/><stop stop-color="rgba(127,127,127,0.15)" offset="0.8"/><stop stop-color="rgba(64,64,64,0.5)" offset="1"/>
            </linearGradient>
            <radialGradient id="g120" gradientUnits="objectBoundingBox" cx="50%" cy="50%" r="70%">
            <stop stop-color="#FFF" offset="0"/><stop stop-color="#FFF" offset="0.5"/><stop stop-color="#000" offset="1"/>
            </radialGradient>
            <linearGradient id="g121" gradientUnits="objectBoundingBox" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop stop-color="#333" offset="0"/><stop stop-color="#CCC" offset="0.5"/><stop stop-color="#222" offset="1"/>
            </linearGradient>
			<path id="BitmapHVCA" stroke="#222" fill="none" d="M0,6 L5,6 M21,6 L16,6 5,11.5 5,0 16,6" />
			<path id="BitmapVVCA" stroke="#222" fill="none" d="M6,0 L6,5 M6,21 L6,16 11.5,5 0,5 6,16" />
			<path id="BitmapWSAW" stroke="#222" fill="none" d="M0,9 L0,2 13,8.5" />
			<path id="BitmapWSQR1" stroke="#222" fill="none" d="M0,5.5 L0,2 7,2 7,8.5 13,8.5 13,5.5" />
			<path id="BitmapWSQR2" stroke="#222" fill="none" d="M2,5.5 L2,2 9,2 9,8.5 15,8.5 15,5.5" />
			<path id="BitmapINV" stroke="#222" fill="none" d="M3,12 L13,7 3,2 3,12 M15.5,7 m-2,0 a2,2 0 1,1 4,0 a2,2 0 1,1 -4,0" />
			<path id="BitmapSW12" stroke="#222" fill="none" d="M0,12 l8,0 a1.2,1.2 0 1,1 4,0 a2,2 0 1,1 -4,0 m2.5,-1.5 l3,-6 0,-4.5 M15,12 a1.2,1.2 0 1,1 4,0 a2,2 0 1,1 -4,0 m4,0 l4,0" />
			<path id="BitmapSH" stroke="#222" fill="none" d="M0,12 l6,0 10,-6 M12,0 l0,7 M15,12 a1.2,1.2 0 1,1 4,0 a2,2 0 1,1 -4,0 m4,0 l4,0 m0,5 l10,0 0,-10 -10,0 z m2,-1.5 l0,-7 3,3 3,-3 0,7" />
			<path id="BitmapLMOD" stroke="#222" fill="none" d="M0,24 l6,0 M21,24 l-5,0 -10,6 0,-12 10,6 M0,3 l6,0 m0,-2 l9,0 0,4 -9,0 0,-4 m9,2 l4,0 0,10 -8,0 0,8" />
			<g id="levelShift0">
				<path stroke="none" fill="#8F8" d="M1,0 l12,0 0,5.5 -12,0z M1,6 l12,0 0,5.5 -12,0z" />
				<path stroke="#222" fill="#222" d="M7,1 l1.5,2 -3,0 z M7,3 l0,8" />
			</g>
            <g id="check">
                <path stroke="#666" d="M0,0 l10,0 0,10 -10,0 0,-10" />
            </g>
            <g id="onoff">
                <path stroke="#666" d="m1,0 l11.5,0 0,11.5 -11.5,0 0,-11.5 M6.77,1.5 l0,4.5" />
                <path stroke="#666" fill="none" d="M5.5,1.75 A4.25,4.25 0 1 0 8,1.75" />
            </g>
            <g id="input">
                <circle r="5" cx="6" cy="5" stroke="#333" filter="url(#f4)" />
                <circle r="3"  cx="6" cy="5" fill="black" />
            </g>
            <g id="output">
                <path stroke="#333" d="m1,0 l10,0 0,10 -10,0 0,-10" filter="url(#f4)" />
                <circle r="3"  cx="6" cy="5" fill="black" />
            </g>
            <g id="KnobSlider" stroke="#333">
                <path stoke="#333" fill="#CCC" d="M0,0 l10,0 0,62 -10,0 0,-62 M0,46 l10,0 M0,54 l10,0" />
                <path stoke="none" fill="#333" d="M2.5,51 l5,0 -2.5,-3 z M2.5,57 l5,0 -2.5,3 z" />
            </g>
            <g id="KnobSmall" stroke="#333">
                <line x1="0.5" y1="17.5" x2="2.5" y2="15.5" />
                <line x1="18.5" y1="17.5" x2="16.5" y2="15.5" />
                <circle r="9" cx="9.5" cy="9.5" fill="url(#g120)" filter="url(#f3)" />
            </g>
            <g id="KnobMedium" stroke="#333">
                <line x1="1" y1="19" x2="3" y2="17" />
                <line x1="20" y1="19" x2="18" y2="17" />
                <circle r="10" cx="10.5" cy="10.5" fill="url(#g120)" filter="url(#f3)" />
            </g>
            <g id="KnobReset" stroke="#333">
				<path fill="green" stroke="black" d="m7,2 l6,0 -3,4 z" />
                <line x1="1" y1="25" x2="3" y2="23" />
                <line x1="20" y1="25" x2="18" y2="23" />
                <circle r="10" cx="10.5" cy="16.5" fill="url(#g120)" filter="url(#f3)" />
            </g>
            <g id="KnobBig" stroke="#333">
                <line x1="1" y1="21" x2="3" y2="19" />
                <line x1="22" y1="21" x2="20" y2="19" />
                <circle r="11" cx="11.5" cy="11.5" fill="url(#g120)" filter="url(#f3)" />
            </g>
        </defs>
		
    </svg>
	<pre id="pre" style="font-size:6pt"></pre>
    <script type="text/javascript">
		var toggleEnd = 0;
        var xmlns="http://www.w3.org/2000/svg";
		var globStr = {}; // hash table for switch states
		var type2colour = {Logic:"#f2f26d", Audio:"#f26d6d", Control:"#6d6df2"};
		document.getElementById("knob_shadow").onclick = function (e) {
			var f = e.target.checked?"url(#f3)":"none";
			var c = document.querySelectorAll("g[id^=Knob] circle");
			Array.prototype.slice.call(c,0).forEach( function (i) {
				i.setAttributeNS(null,"filter",f);
			});
		}
		document.getElementById("scaler").oninput = function (e) {
			var p = document.getElementById("alldefs").parentElement;
			var w = p.width.baseVal.value;
			var h = p.height.baseVal.value;
			var scale = Math.abs(e.target.value / 2);
			var ovb = p.getAttribute("viewBox").split(" ");
			var vb = ovb.slice(0,2).join(" ")+" "+Math.floor(w*scale)+" "+Math.floor(h*scale);
			p.setAttribute("viewBox", vb);
		}
		document.getElementById("shifter").oninput = function (e) {
			var p = document.getElementById("alldefs").parentElement;
			var shift = e.target.value;
			var ovb = p.getAttribute("viewBox").split(" ");
			var vb = shift+" 0 "+ovb.slice(2).join(" ");
			p.setAttribute("viewBox", vb);
		}
		function svgNSGet(tag, attr) {
			var a, se = (typeof tag == "object")?tag:document.createElementNS(xmlns, tag);
			for (a in attr)
				if (a=="innerHTML"||a=="textContent")
					se[a] = attr[a];
				else
					se.setAttributeNS(null,a,attr[a]);
			return se;
		}
		function hashCode(s){
			var r = s.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);
			return Math.abs(r);
		}
		function makeSubElements(s,sub)
		{
			sub.forEach( function (n) { // two passes (or pre-sort for correct render order
				switch (n.type) {
				case "Symbol":
					s.appendChild(svgNSGet("text", {x:n.XPos, y:6.5+n.YPos, fill:"#000", innerHTML:"&uarr;"}));
					break;
				case "Graph":
					s.appendChild(svgNSGet("rect",{x:n.XPos, y:n.YPos, width:n.Width, height:n.Height, fill:"#282"}));
					break;
				case "Line":
					var points;
					var x = parseInt(n.XPos)+1;
					var y = parseInt(n.YPos);
					var l = parseInt(n.Length);
					var th = 0;
					if (n.Width=="Thick")
						th = 2;
					if (n.Orientation.charAt(0)=="H")
						points = {"stroke":"#333", x1:x, y1:th+y, x2:x+(l*1), y2:th+y};
					else
						points = {"stroke":"#333", x1:x, y1:y, x2:x, y2:y+(l*1)};
					s.appendChild(svgNSGet("line", points));
					break;
				default:
					break;
				}
			});
			sub.forEach( function (n) {
				switch (n.type) {
				case "TextField":
					s.appendChild(svgNSGet("rect",{x:n.XPos, y:n.YPos, width:n.Width, height:14, fill:"#666", "data-id":n.MasterRef, "data-f":n.f}));
					break;
				case "Led":
					var p = {Sequencer:{w:10, h:6, c:"#060"},Green:{w:6.5, h:6.5, c:"#8F8"}}[n.Type];
					s.appendChild(svgNSGet("rect",{fill:p.c, stroke:"#000", width:p.w, height:p.h, y:n.YPos, x:n.XPos}));
					break;
				case "ButtonText":
				case "ButtonFlat":
					var t = svgNSGet("svg",{x:n.XPos, y:n.YPos, width:n.Width, fill:"#6df2f2"});
					var u = document.createElementNS(xmlns,"use");
					var tx;
					if (n.Width==13)
						u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#onoff");
					else {
						u = svgNSGet("rect",{height:10, width:n.Width-2, stroke:"#222"});
						if (n.Text) {
							// dont make a text element here as it belongs in individual control element like dial,
							// get hash for n.text, append to class, save hash:text in dictionary
							var tarray = n.Text.split(",");
							var hash = hashCode(n.Text).toString(16);
							globStr[hash] = tarray;
							t.setAttributeNS(null,"class","SwM"+hash);
						}
					}
					t.appendChild(u);
					s.appendChild(t);
					break;
				case "Bitmap":
					var t = svgNSGet("svg", {x:n.XPos, y:n.YPos});
					var u = document.createElementNS(xmlns,"use");
					var classn = n.type+n.ID;
					u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#"+classn);
					t.appendChild(u);
					s.appendChild(t);
					break;
				case "Knob":
					var classn = n.type+n.Type;
					var t = svgNSGet("svg",{"class":classn, x:n.XPos, y:n.YPos});
					var u = document.createElementNS(xmlns,"use");
					u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#"+classn);
					t.appendChild(u);
					s.appendChild(t);
					break;
				case "LevelShift":
					var t = svgNSGet("svg",{"class":"levelshift", x:n.XPos, y:n.YPos});
					var u = document.createElementNS(xmlns,"use");
					u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#levelshift0");
					t.appendChild(u);
					s.appendChild(t);
					break;
				case "Input":
				case "Output":
					var colour = type2colour[n.Type];
					var t = svgNSGet("svg",{"fill":colour, x:n.XPos, y:n.YPos});
					var u = document.createElementNS(xmlns,"use");
					var classn = (n.type=="Input")?"#input":"#output";
					u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",classn);
					t.appendChild(u);
					s.appendChild(t);
					break;
				case "Text":
					s.appendChild(svgNSGet("text",{fill:"black", x:n.XPos-1, y:n.YPos+7, innerHTML:n.Text}));
					break;
				default:
					break;
				}
			});
		}
		function makeBasicPanel(s,id,h,type)
		{
			s.setAttributeNS(null, "id", type);
			s.appendChild(svgNSGet("rect", {width:"256",height:h}));
			s.appendChild(svgNSGet("rect", {width:"256",height:h,fill:"url(#g119)"}));
			s.appendChild(svgNSGet("path", {fill:"none",stroke:"#000",d:"m0.5,0.5 0,"+h+" 255,0"}));
			s.appendChild(svgNSGet("path", {fill:"none",stroke:"#FFF",d:"m1.5,0.5 l254,0 0,"+h}));
		}
		function addModuleTemplate(id, xpos, ypos)
		{
			modcolours = ["#c0c0c0",
				"#e5777a","#ba7d81","#ca8d8d","#ccbaba",
				"#e7d14b","#dec77d","#ded1a5","#d0cbaa",
				"#93d162","#82b980","#94cf9c","#baccba",
				"#69d6c7","#7bc1bd","#a0d2c8","#bed2d2",
				"#74a0d4","#808cc0","#8f9ac2","#b0bacc",
				"#d673c7","#be82be","#cda0d2","#d2bed2"];
			// get module description and build a template
			var o = nmg2mods[id];
			var defs = document.getElementById("alldefs");
			
			var h = o.height * 15;

			// need to check if we have done this one already
			var s = document.getElementById(o.type);
			if (!s) {
				s = document.createElementNS(xmlns,"svg");
				makeBasicPanel(s,id,h,o.type);
				makeSubElements(s,o.sub);
				
				defs.appendChild(s);
			}
			var g = svgNSGet("g",{"class":"module",transform:"translate("+xpos+","+ypos+")"});
			var u = document.createElementNS(xmlns,"use");
			u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#"+s.id);
			u.setAttributeNS(null,"fill",modcolours[Math.floor(Math.random()*24)]);
			g.appendChild(u);
			defs.parentElement.appendChild(g);
			return h;
		}
        function mdown(e) {
            // get control element for this control
            var ss = e.target.nextSibling;
			window.globScale = ss.ownerSVGElement.currentScale;
            var control = ss.parentElement.controls.filter(function (c) { return c.sv === ss })[0];
            window.globTarget = control;
            control.mdx = e.screenX;
            document.addEventListener("mousemove", mmove, false);
            document.addEventListener("mouseup", mup, false);
        }
        function mmove(e) {
            var deltax = (e.screenX - window.globTarget.mdx)/window.globScale;
            var newx = window.globTarget.a + deltax;
            newx = Math.max(-130, Math.min(130, newx));
            window.globTarget.a = newx;
            var dial = window.globTarget.sv;
            var oldt = dial.getAttribute("transform");
            var newt = oldt.replace(/rotate\([\d|\.|-]* /, "rotate(" + newx + " ");
			if (newt != oldt)
			{
				dial.setAttribute("transform", newt);
				if (globTarget.tw) {
					var f = window[globTarget.f];
					var i = Math.floor((newx+130)/2.047244094488189);
					var t = " "+i;
					if (f)
						t = f(i);
					globTarget.tw.innerHTML = t;
				}
			}
        }
        function mup(e) {
            document.removeEventListener("mousemove", mmove, false);
            document.removeEventListener("mouseup", mup, false);
        }
        function updateknob() {
            var e = document.getElementById("test");
            var k = globModules[0].controls[0];
            k.a = e.value;
            var oldt = k.sv.getAttribute("transform");
            oldt = oldt.replace(/rotate\([\d|\.|-]* /, "rotate(" + k.a+" ");
            k.sv.setAttribute("transform", oldt);
        }
        document.addEventListener("DOMContentLoaded", dom_ready);
		
		function addCord(e) {
			var trans = e.target.parentElement.attributes["transform"].value;
			var xo = ((trans)?parseInt(trans.substr(10)):0);
			var x = e.target.cx.baseVal.value + xo;
			var y = e.target.cy.baseVal.value + ((trans)?parseInt(trans.substr(11+(xo.toString().length))):0);
			//alert(x+":"+y);
			svgcable = document.getElementById("svgcable");
			var pp = new Point(x/1024,y/600);
			cable.points[toggleEnd].setCurrent(pp.getCurrent());
			toggleEnd = (toggleEnd)?0:cable.points.length-1;
		}
        function dom_ready() {
			var mposx = 0;
			var mposy = 0;
			//[0x05,0x11,0x12,0x24,0x2f,0x32,0x35,0x39,0x3a,0x4c,0x55,0x5a,0x64,0x69,0x70,0x71,0x72,0x75,0x8b,0x8d,0x8e,0x8f,0xb4,0xba,0xbb,0xbc].forEach( function (e,i) {
			[0xC0,0xA2,0xA3,0xA4,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,,0x70,0x71,0x72,0x75,0x8b,0x8d,0x8e,0x8f,0xb4,0xba,0xbb,0xbc,
			0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x92].forEach( function (e,i) {
				mposy += addModuleTemplate(e, mposx, mposy)+1;
				if (mposy>550)
				{
					mposx+=256;
					mposy=0;
				}
			});
            globModules = document.getElementsByTagName("g");
            Array.prototype.slice.call(globModules, 0).forEach(function (e) {
				if (e.className.baseVal!="module")
					return;
                var controls = [];
                var tmpl8 = document.getElementById(e.firstChild.href.baseVal.slice(1));
				// input/output
				var io = tmpl8.querySelectorAll("use[*|href$='put']");
				Array.prototype.slice.call(io, 0).forEach(function (i) {
                    var cx = 6+i.parentElement.x.baseVal.value;
                    var cy = 5+i.parentElement.y.baseVal.value;
					var pcd = svgNSGet("circle", {cx:cx, cy:cy, r:3, fill:"rgba(0,0,0,0.25)", "class":"io"});
					pcd.onclick = addCord;
					e.appendChild( pcd);
				});
				var valwindow = tmpl8.querySelectorAll("rect[fill='#666']");
                Array.prototype.slice.call(valwindow, 0).forEach(function (vw) {
					var text = document.createElementNS(xmlns, "text");
					for (pp in $$={"x":3+vw.x.baseVal.value, "y":9.5+vw.y.baseVal.value, "fill":"#FFF"})
						text.setAttributeNS(null,pp,$$[pp]);
					var id = vw.getAttribute("data-id");
					var f = vw.getAttribute("data-f");
					text.setAttributeNS(null,"data-id",id);
					text.setAttributeNS(null,"data-f",f);
					text.innerHTML = id;
					e.appendChild(text);
				});
                // make element for each knob/control in template
                var k = tmpl8.querySelectorAll("svg[class]");
                Array.prototype.slice.call(k, 0).forEach(function (knob) {
                    var n = knob.className.baseVal;
                    if (n.charAt(0) == "_") {
                    } else {
                        var dial;
                        var area;
                        var x = knob.x.baseVal.value + knob.children[0].x.baseVal.value + 0.5;
                        var y = knob.y.baseVal.value + knob.children[0].y.baseVal.value + 0.5;
						if (n.substr(0,3)=="SwM") {
							// switch
							var ta = globStr[n.substr(3)];
							dial = svgNSGet("text", {x:x+0.5, y:y+8, fill:"black", innerHTML:ta[0]});
							area = svgNSGet("rect", {x:x, y:y, width:knob.width.baseVal.value-3, height:9, fill:"rgba(44,0,0,0.01)","class":n.substr(3)});
							ang = (ta.length==1)?1:0;
						} else {
							var ktype = knob.className;////children[0].href.baseVal;
							var kdic = {KnobBig:{r:11,cy:11},KnobMedium:{r:10,cy:10},KnobSlider:{r:0,cy:10},
								KnobReset:{r:10,cy:16},KnobSmall:{r:9,cy:9},levelshift:{r:-1,cy:12}};
							var r = kdic[ktype.baseVal];
							/* for debug, tag controls
							var tag = document.createElementNS(xmlns, "text");
							for (pp in $$={"x":x,"y":y,fill:"red","font-size":7})
								tag.setAttribute(pp, $$[pp]);
							tag.innerHTML = controls.length;
							*/
							if (r.r>0) // has a radius?
							{
								var ang = Math.random() * 240 - 120;
								area = svgNSGet("circle",{r:r.r, cx:x+r.r, cy:y+r.cy, class:"knob", fill:"rgba(44,0,0,0.01)"});
								dial = svgNSGet("line",{x1:x + r.r, y1:y+(r.cy-r.r), x2:x + r.r, y2:y + r.cy-3, stroke:"black"});
								dial.setAttribute("transform", "rotate(" + (ang) + " " + (x + r.r) + " " + (y + r.cy) + ")");
							}
							else // slider or levelshift
							{
								var pos = Math.random() * 40;
								area = svgNSGet("rect",{x:x, y:y, width:r.cy, height:(r.r<0)?r.cy:62, fill:"rgba(44,0,0,0.01)"});
								if (r.r==0)
									dial = svgNSGet("rect",{x:x, y:y, width:r.cy-1, height:6, fill:"url(#g121)", stroke:"none", transform:"translate(0," + (pos) + ")"});
								else {
									dial = svgNSGet("svg", {x:x, y:y});
									var u = document.createElementNS(xmlns,"use");
									u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#levelShift0");
									dial.appendChild(u);
								}
							}
						}
						var sv;
						if (r&&r.r>=0) {
							area.onmousedown = mdown;
						} else {
							// multistate button
							dial.onclick = function(e) {
								// get text array
								var ss = e.target;
								var control = ss.parentElement.controls.filter(function (c) { return c.sv === ss })[0];
								var ta = globStr[ss.previousSibling.className.baseVal];
								if (ta.length==1) {
									control.a = (control.a)?0:1;
									ss.previousSibling.setAttribute("fill",(control.a)?"rgba(44,0,0,0.01)":"white");
								} else {
									control.a = (control.a+1)%ta.length;
									ss.innerHTML = ta[control.a];
								}
							};
						}
                        e.appendChild(area);
						sv = e.appendChild(dial);
						//e.appendChild(tag);
                        controls.push({ sv: sv, a: ang, mdx:0 });
                    }
                });
				// get all the value text objects and xref to controls
                var tw = e.querySelectorAll("text[data-id]");
                Array.prototype.slice.call(tw, 0).forEach(function (textwindow) {
					try {
						var id = parseInt(textwindow.getAttribute("data-id"));
						var f =  textwindow.getAttribute("data-f");
						controls[id].tw = textwindow;
						controls[id].f = f;
					} catch (e) {
					}
				});
                e.controls = controls;
            });
			if (!Array.prototype.findIndex) {
			  Array.prototype.findIndex = function(predicate) {
				if (this == null) {
				  throw new TypeError('Array.prototype.find called on null or undefined');
				}
				if (typeof predicate !== 'function') {
				  throw new TypeError('predicate must be a function');
				}
				var list = Object(this);
				var length = list.length >>> 0;
				var thisArg = arguments[1];
				var value;

				for (var i = 0; i < length; i++) {
				  value = list[i];
				  if (predicate.call(thisArg, value, i, list)) {
					return i;
				  }
				}
				return -1;
			  };
			}		
			var psvg = document.getElementById("alldefs").parentElement;
			var ssh = svgNSGet("path", {d:"M5.5,1.75 A4.25,4.25 0 1 0 8,1.75"});
			ssh.id = "svgcable";
			psvg.appendChild(ssh);
			window.cable = new Cable(psvg);
				var inputs = {}, point,
				key_down, mouse_down, mouse;
			
			var position = function(event){
				return {
					x: event.pageX,
					y: event.pageY
				};
			};
			
			var setPoint = function(inv_mass){
				if (!point) return;
				if (mouse) {
					point.setCurrent(mouse);
					point.setPrevious(mouse);
				}
				point.inv_mass = inv_mass;
			};

			var ev = {
				'keydown': function(event){
					key_down = true;
				},
				
				'keyup': function(){
					key_down = false;
				},
				
				'mousedown': function(event){
					mouse_down = true;
					mouse = position(event);
					
					if (!mouse) return;
					
					point = cable.getClosestPoint(mouse);
					setPoint(0);
				},
				
				'mouseup': function(event){
					mouse_down = false;
					if (mouse) setPoint( key_down ? 0 : 1);
				},
				
				'mousemove': function(event){
					if (!mouse_down) return;
					
					mouse = position(event);
					setPoint(mouse ? 0 : 1);
				}
			};
			setInterval(cable.update.bind(cable), 25);
			///for (e in ev)
				///document.addEventListener(e, ev[e], false);
			
			/*
			var pre = document.getElementById("pre");
			var list = [];
			for (var m in nmg2mods) {
				var bma = nmg2mods[m].sub.filter( function (e) { return e.type=="Bitmap" && !e.ID["charAt"] });
				if (bma.length) {
					pre.appendChild( document.createTextNode("0x"+parseInt(m).toString(16)+":"+nmg2mods[m].type+"\t\t"+JSON.stringify(bma)+"\n"));
					list.push("0x"+parseInt(m).toString(16));
				}
			}
			pre.appendChild( document.createTextNode(list.join(",")+"\n"));
			
			for (var m in moduleDic) {
				// find def in mods
				var ix = mods.findIndex( function (e) { return(moduleDic[m].type==e.Name)});
				if (ix>=0) {
					moduleDic[m]["height"] = mods[ix].Height;
					moduleDic[m]["sub"] = mods[ix].sub;
				}
				pre.appendChild( document.createTextNode("{0x"+parseInt(m).toString(16)+":"+JSON.stringify(moduleDic[m])+"},\n"));
			}*/
        }
		// wobbly cable stuff

		var FastVector  = function(x,y){
			this.x = x;
			this.y = y;
		};

		FastVector.prototype = {
			
			add: function (B,internal) {
				var nx, ny;
				if (typeof(B)=='number'){
					nx = this.x+B;
					ny = this.y+B;
				}else{
					nx = this.x+B.x;
					ny = this.y+B.y;
				}
				return new FastVector(nx,ny);
			},
			dot: function(B) {
				return ((this.x*B.x)+(this.y*B.y));
			},
			length: function() {
				return Math.sqrt((this.x*this.x)+(this.y*this.y));
			},
			multiply: function(B) {
				var nx, ny;
				if (typeof(B)=='number'){
					nx = this.x*B; ny = this.y*B;
				}else{ 
					nx = this.x*B.x; ny = this.y*B.y;
				}
				return new FastVector(nx,ny);
			},
			squaredLength: function(args) {
				return (this.x*this.x)+(this.y*this.y);
			},
			sum: function(){
				return this.x+this.y;
			},
			subtract: function(B) {
				var nx, ny;
				if (typeof(B) == 'number'){
					nx = this.x-B; ny = this.y-B;
				}else{
					nx = this.x-B.x; ny = this.y-B.y;
				}
				return new FastVector(nx,ny);
			},
			toString: function() {
				return "["+this.x+","+this.y+"]";
			}

		};

		var Point = function(x, y){
			this.current = this.previous = new FastVector(x, y);
			
			this.mass = this.inv_mass = 1;
			
			this.force = new FastVector(0.0,0.05).multiply(0.3 * 0.3);
			this.radius = 3;
		};

		Point.prototype = {
			
			setCurrent: function(p) {
				this.current = p;
			},

			setPrevious: function(p) {
				this.previous = p;
			},
			
			getCurrent: function() {
				return this.current;
			},
			
			getPrevious: function() {
				return this.previous;
			},
			
			move: function() {
				if (this.inv_mass!=0){
					var new_pos = this.current.multiply(1.99).subtract(this.previous.multiply(0.99)).add(this.force);
					new_pos.x = (new_pos.x < 0) ? 0 : ((new_pos.x > 1) ? 1 : new_pos.x);
					new_pos.y = (new_pos.y < 0) ? 0 : ((new_pos.y > 1) ? 1 : new_pos.y);
					this.previous = this.current;
					this.current = new_pos;
				}
			}
			
		};

		var Constraint = function(p1, p2, rl){
			this.p1 = p1;
			this.p2 = p2;
			this.rest_length = rl || p1.getCurrent().subtract(p2.getCurrent()).length();
			this.squared_rest_length = this.rest_length * this.rest_length;
		};

		Constraint.prototype = {
			satisfy: function(){
				var p1 = this.p1.getCurrent();
				var p2 = this.p2.getCurrent();
				var delta = p2.subtract(p1);
				
				var p1_im = this.p1.inv_mass;
				var p2_im = this.p2.inv_mass;
				
				var d = delta.squaredLength();
				
				var diff = (d - this.squared_rest_length) / ((this.squared_rest_length + d) * (p1_im + p2_im));
				
				if (p1_im != 0){
					this.p1.setCurrent(p1.add(delta.multiply(p1_im * diff)));
				}
				
				if (p2_im != 0){
					this.p2.setCurrent( p2.subtract(delta.multiply(p2_im*diff)) );
				}
			}
		};
		document.addEventListener("DOMContentLoaded", function(){
		}, false);

		var Cable = function(svg){
			
			var max_points = 4,
				width = svg.width.baseVal.value,
				height = svg.height.baseVal.value,
				max_dim = Math.max(width, height),
				min_dim = Math.min(width, height),
				x_offset = 0,
				y_offset = 0,
				spacing = 160;
			
			this.width = width;
			this.height = height;
			this.num_iterations = 1;
			this.points = [];
			this.constraints = [];
			
			var num_x_points = this.num_x_points = Math.round(max_points * (width / max_dim));
			var num_y_points = this.num_y_points = 1;//Math.round(max_points * (height / max_dim));
			
			var constraint;
			
			var y = y_offset;
			this.points = [];
			
			for (var j = 0, x = x_offset; j < num_x_points; j++, x += spacing){
				var point = new Point(x / width, y / height);
				this.points[j] = point;
							
				//add a new constraint
				if (j > 0){
					constraint = new Constraint(this.points[j - 1], this.points[j]);
					this.constraints.push(constraint);
				}
			}
			//pin the top right and top left.
			this.points[0].inv_mass = 0;
			this.points[num_x_points - 1].inv_mass = 0;

			this.num_constraints = this.constraints.length;
			};

		Cable.prototype = {
			
			update: function() {

				if (!svgcable)
					return;
			
				var num_x = this.num_x_points,
					num_y = this.num_y_points,
					num_c = this.num_constraints,
					num_i = this.num_iterations,
					i, j;
					
				//move each point with a pull from gravity
				for (j = 0; j < num_x; j++)
					this.points[j].move();
				
				//make sure all the constraints are satisfied.
				for (j = 0; j < num_i; j++)
					for (i = 0; i < num_c; i++)
						this.constraints[i].satisfy();
				
				var w = this.width;
				var h = this.height;
				// try a quadratic curve
				var coords = [];
				this.points.forEach( function (p,i) {
					coords.push(p.current.x*w+","+(p.current.y*h));
				});
				// make path
				var p = "M"+coords[0]+" C"+coords.slice(1).join(" ");
				svgcable.setAttribute("d",p);
			},
			
			getClosestPoint: function(pos) {
				var min_dist = 1,
					min_point = null,
					num_x = this.num_x_points,
					num_y = this.num_y_points,
					dist, i, j;
				
				for (j = 0; j < num_x; j++){
					dist = pos.subtract(this.points[j].getCurrent()).length();
					
					if (dist < min_dist){
						min_dist = dist;
						min_point = this.points[j];
					}
				}
				
				return min_point;
			}
		};


    </script>
</body>
</html>
